<?php
/**
 * @file
 * Provides draggable blocks
 *
 * 1) Provides hook to define reusable block types
 *    - User can create "instaces" instances of these blocks and assign to
 *      regions like any other block. These instances are plain Drupal
 *      blocks.
 * 2) Adds ability to edit blocks via context menu & overlay
 * 3) Adds ability to set block weights within a region via drag & drop
 */

/**
 * Define the number of available steps for setting the width of a block.
 */
define('TILES_WIDTH_STEPS', 12);

/**
 * Hook Implementations
 */

/**
 * Implements hook_entity_info().
 */
function tiles_entity_info() {
  return array(
    'tile_layout' => array(
      'label' => t('Tile layout'),
      'entity class' => 'TileLayout',
      'controller class' => 'TileLayoutController',
      'base table' => 'tile_layout',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'tid',
      ),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function tiles_menu() {
  $items['admin/structure/block/manage/%/%/arrange'] = array(
    'title' => 'Move',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'page callback' => '_tiles_move',
    'page arguments' => array(4, 5),
    'access callback' => 'tiles_access',
    'access arguments' => array('move', 4, 5),
    'weight' => -9,
  );

  $items['admin/structure/block/manage/%/%/set_width'] = array(
    'title' => 'Resize',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'page callback' => '_tiles_width',
    'page arguments' => array(4, 5),
    'access callback' => 'tiles_access',
    'access arguments' => array('resize', 4, 5),
    'weight' => -9,
  );

  $items['admin/structure/block/manage/%/%/set_visibility'] = array(
    'title' => 'Visibility',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'page callback' => '_tiles_visibility',
    'page arguments' => array(4, 5),
    'access callback' => 'tiles_access',
    'access arguments' => array('resize', 4, 5),
    'weight' => -9,
  );

  $items['admin/tiles/add'] = array(
    'title' => 'Add Block',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tiles_add_form', 3, 4),
    'access arguments' => array('add tiles'),
    'file' => 'tiles.admin.inc',
  );

  $items['admin/tiles-save-tiles'] = array(
    'title' => 'Save tiles weight and width',
    'page callback' => '_tiles_save_tiles',
    'access arguments' => array('arrange tiles'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function tiles_menu_alter(&$items) {
  // Override block delete to handle deleting block from tile group. Also show
  // delete in contextual menu.
  $items['admin/structure/block/manage/%/%/delete']['title'] = t('Delete');
  $items['admin/structure/block/manage/%/%/delete']['type'] = MENU_LOCAL_TASK;
  $items['admin/structure/block/manage/%/%/delete']['context'] = MENU_CONTEXT_INLINE;
  $items['admin/structure/block/manage/%/%/delete']['page callback'] = 'tiles_delete';
  $items['admin/structure/block/manage/%/%/delete']['page arguments'] = array(4, 5);
  $items['admin/structure/block/manage/%/%/delete']['access callback'] = 'tiles_access';
  $items['admin/structure/block/manage/%/%/delete']['access arguments'] = array('delete', 4, 5);
  $items['admin/structure/block/manage/%/%/delete']['file'] = 'tiles.admin.inc';
  $items['admin/structure/block/manage/%/%/delete']['module'] = 'tiles';
}

/**
 * Permission callback for menus.
 */
function tiles_access($op, $module, $delta) {
  // Default to just checking if a block is a tile and if user has access to
  // arrange tiles.
  $access = user_access('arrange tiles') && tiles_is_tile($module, $delta);

  // Allow other modules to alter access.
  $context = array(
    'op' => $op,
    'module' => $module,
    'delta' => $delta,
  );
  drupal_alter('tiles_access', $access, $context);

  return $access;
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function tiles_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add "Add a Block" link to all pages that aren't admin paths.
  if (user_access('add tiles') && _tiles_has_block_access() && !path_is_admin(current_path())) {
    if (!$data['tabs']) {
      $data['tabs'][0] = array(
        'count' => 0,
        'output' => array(),
      );
    }

    $data['tabs'][0]['output'][] = array(
      '#theme' => 'menu_local_task',
      '#link' => array(
        'title' => t('Add Block'),
        'href' => 'admin/tiles/add/region',
        'localized_options' => array(
          'query' => drupal_get_destination(),
          'attributes' => array(
            'title' => t('Add a new block to this page'),
          ),
        ),
      ),
    );

    // Make sure the Add Block link shows up even for pages that don't have
    // local tasks.
    if ($data['tabs'][0]['count'] == 1) {
      $data['tabs'][0]['count']++;
    }
  }

}

/**
 * Implements hook_module_implements_alter().
 */
function tiles_module_implements_alter(&$implementations, $hook) {
  if (in_array($hook, array('page_alter', 'menu_alter'))) {
    $group = $implementations['tiles'];
    unset($implementations['tiles']);
    $implementations['tiles'] = $group;
  }
}

/**
 * Implements hook_permission().
 */
function tiles_permission() {
  return array(
    'administer tiles' => array(
      'title' => t('Administer tiles'),
    ),
    'arrange tiles' => array(
      'title' => t('Arrange tiles'),
    ),
    'add tiles' => array(
      'title' => t('Add new tiles'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function tiles_theme() {
  return array(
    'tiles_region' => array(
      'render element' => 'element',
    ),
    'tiles_row' => array(
      'render element' => 'element',
    ),
    'tiles_tile' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Implements hook_page_build().
 */
function tiles_page_build(&$page) {
  $container = tiles_get_container('region');
  $layout = $container->getLayout(current_path());
  $container->buildPage($page, $layout);

  // Add block weight to all blocks.
  foreach (element_children($page) as $region_key) {
    foreach (element_children($page[$region_key]) as $block_key) {
      // Only set the width of the block if it is not already set.
      if (isset($page[$region_key][$block_key]['#block'])) {
        $block = $page[$region_key][$block_key]['#block'];
        if (!isset($block->width)) {
          $page[$region_key][$block_key]['#block']->width = tiles_get_width($block->module, $block->delta);
        }
      }
    }
  }
}

/**
 * Implements hook_page_alter().
 *
 */
function tiles_page_alter(&$page) {
  // Don't alter page if loading media modal window.
  // @todo: need an abstract way of handling content where tiles shouldn't be
  // active.
  if (current_path() == 'media/browser') {
    return;
  }

  $container = tiles_get_container('region');
  foreach (element_children($page) as $region_key) {
    // Allow regions to bypass block wrapping.
    if (in_array($region_key, variable_get('tiles_skip_regions', array()))) {
      continue;
    }

    $container->wrapRegion($page[$region_key]);
  }
}

/**
 * Implements hook_preprocess_block().
 */
function tiles_preprocess_block(&$variables) {
  if (_tiles_has_block_access()) {
    _tiles_js_init();
  }

  // Add weight to block.
  $block = $variables['block'];
  if (tiles_is_tile($block->module, $block->delta)) {
    $variables['classes_array'][] = 'tile';

    // Add data attributes to tiles to facilitate moving.
    $variables['attributes_array']['data-module'] = $block->module;
    $variables['attributes_array']['data-delta'] = $block->delta;
    $variables['attributes_array']['data-width'] = $block->width;

    // Add widths for each of the breakpoints.
    $default_breakpoint = tiles_get_default_breakpoint();
    $default_width = isset($block->breakpoints[$default_breakpoint]) ? $block->breakpoints[$default_breakpoint] : tiles_get_max_step();
    $breakpoints = tiles_get_breakpoints();
    foreach ($breakpoints as $key => $value) {
      $width = isset($b->breakpoints[$key]) ? $b->breakpoints[$key] : $default_width;
      $variables['attributes_array']['data-width-' . $key] = $width;
    }

    // Load bean type if block is a bean. Used in
    // tiles_contextual_links_view_alter() to display the bean type in
    // contextual links.
    if ($block->module == 'bean') {
      $types = bean_get_types();
      $bean = bean_load_delta($block->delta);
      $block->bean_type = $types[$bean->type]->getLabel();
    }
  }
}

/**
 * Implements hook_block_view_MODULE_DELTA_alter().
 */
function tiles_block_view_system_main_alter(&$build, $block) {
  // Add contextual links to build array for system main, to allow system main
  // block to be orderable.  Only do this for front end theme.
  if (!path_is_admin(current_path())) {
    $build['content']['#contextual_links']['block'] = array(
      'admin/structure/block/manage', array(
        $block->module,
        $block->delta,
      ),
    );
  }
}

/**
 * Implements hook_tiles_info().
 */
function tiles_tiles_info() {
  $tiles = array(
    'blocks' => array(),
    'bean types' => array(),
  );

  // Add system main as a tile.
  $tiles['blocks'][] = 'system__main';

  if (module_exists('bean')) {
    // Add all bean types that the current user has permission to edit.
    $types = bean_get_types();
    foreach ($types as $k => $v) {
      if (user_access('administer beans') || user_access("view any $k bean")) {
        $tiles['bean types'][] = $k;
      }
    }
  }
  return $tiles;
}

/**
 * Implements hook_contextual_links_view_alter().
 */
function tiles_contextual_links_view_alter(&$element, $items) {
  // Remove configure block link for all blocks.
  // @todo: make this a setting?
  if (isset($element['#element']['#block'])) {
    $block = $element['#element']['#block'];
    unset($element['#links']['block-configure']);

    // Remove the delete link for system main block.
    if ($block->module == 'system' && $block->delta == 'main') {
      unset($element['#links']['block-delete']);
    }

    // Add block type to links.
    if ($block->module == 'bean' && tiles_is_tile('bean', $block->delta) && user_access('arrange tiles')) {
      $element['#links'] = array(
        'bean-type' => array(
          'title' => $element['#element']['#block']->bean_type,
          'href' => current_path(),
        ),
      ) + $element['#links'];
    }
  }
}

/**
 * Implements hook_admin_paths().
 */
function tiles_admin_paths() {
  return array(
    'node/*/add-block' => TRUE,
    'taxonomy/term/*/add-block' => TRUE,
  );
}

/**
 * Implements hook_node_insert().
 */
function tiles_node_insert($node) {
  // Allow tiles to be setup programmatically by assigning appropriate blocks to
  // the 'tiles' property on the node object.
  if (isset($node->tiles)) {
    $layout = tiles_get_container('region')->getLayout('node/' . $node->nid);
    foreach ($node->tiles as $tile) {
      $layout->addBlock($tile);
    }
    $layout->save();
  }
}

/**
 * Implements hook_bean_access().
 *
 * @todo: remove dependency on context.
 */
function tiles_bean_access($bean, $op, $account) {
  // Tie tile based beans visibility to menu access.
  // if ($bean && $op == 'view' && ($context = _tiles_get_active_context()) && isset($context->reactions['tiles']['blocks'])) {

  //   if (array_key_exists('bean-' . $bean->delta, $context->reactions['tiles']['blocks'])) {
  //     $item = menu_get_item(current_path());
  //     return $item['access'] && current_path() != variable_get('site_403', FALSE) && user_access('view any ' . $bean->type . ' bean');
  //   }
  // }
}

/**
 * Implements hook_block_view_alter().
 *
 * @todo: remove dependency on context.
 */
function tiles_block_view_alter(&$data, $block) {
  // Tie tile based block visibility to menu access.
  // if (($context = _tiles_get_active_context()) && isset($context->reactions['tiles']['blocks'])) {
  //   if (array_key_exists($block->module . '-' . $block->delta, $context->reactions['tiles']['blocks'])) {
  //     $item = menu_get_item();
  //     if (!$item['access']) {
  //       $data['content'] = '';
  //     }
  //   }
  // }
}

/**
 * Implements hook_page_delivery_callback_alter().
 */
function tiles_page_delivery_callback_alter(&$callback) {
  if (isset($_SERVER['HTTP_X_TILES']) && $_SERVER['HTTP_X_TILES']) {
    if (($container = tiles_get_container($_SERVER['HTTP_X_TILES']))) {
      $callback = 'tiles_handle_callback_request';
    }
  }
}

/**
 * Implements hook_tiles_container_info().
 */
function tiles_tiles_container_info() {
  return array(
    'region' => 'TilesRegionContainer',
  );
}

/**
 * Implements hook_bean_delete().
 *
 * Respond to bean deletions by removing block from tiles contexts.
 */
function tiles_bean_delete($bean) {
  db_delete('tile_layout_blocks')
    ->condition('module', 'bean')
    ->condition('delta', $form['#bean']->delta)
    ->execute();

  // Clear block and page cache.
  cache_clear_all();
}

/**
 * Implements hook_bean_cache_clear().
 *
 * Clear all caches when bean cache is cleared, in order for new bean content to
 * show on cached pages.
 */
function tiles_bean_cache_clear() {
  cache_clear_all();
}

/**
 * Public API functions
 */

/**
 * Returns an array of block/bean types defined by hook_tiles_info().
 *
 * @return array
 *   Array of blocks and bean types available for tiles in the form of
 *   MODULE__DELTA.
 */
function tiles_get_tile_types() {
  $tiles = &drupal_static(__FUNCTION__, array());

  if (empty($tiles)) {
    $tiles = array(
      'blocks' => array(),
      'bean types' => array(),
    );

    foreach (module_implements('tiles_info') as $module) {
      $tiles = array_merge_recursive($tiles, module_invoke($module, 'tiles_info'));
    }
    drupal_alter('tiles_info', $tiles);
  }

  return $tiles;
}

/**
 * Returns info from tiles_get_tile_types with appropriate labels.
 *
 * Useful when showing a list of available blocks/types in an option form.  For
 * example, see tiles_add_form(). Also checks if current user has access to edit
 * bean types.
 */
function tiles_get_tile_types_options() {
  $tiles_options = &drupal_static(__FUNCTION__, array());

  if (empty($tiles_options)) {
    $tiles_options = array(
      'blocks' => array(),
      'bean types' => array(),
    );

    $tiles = tiles_get_tile_types();

    // Add labels to blocks.
    foreach ($tiles['blocks'] as $slug) {
      // Remove main page content from available options. This block is only set
      // as a tile in order to allow the main page content to be moved.
      if ($slug == 'system__main') {
        continue;
      }

      // Get the label from the module hook_block_info().
      list($module, $delta) = explode('__', $slug);
      $block_info = call_user_func($module . '_block_info');
      $tiles_options['blocks'][$slug] = $block_info[$delta]['info'];
    }

    // Add labels to bean types.
    if (!empty($tiles['bean types'])) {
      $bean_types = bean_get_types();
      foreach ($tiles['bean types'] as $type) {
        // Check edit access on bean type, since user should not be able to
        // create new blocks without proper access.
        if (user_access("edit any $type bean")) {
          $tiles_options['bean types'][$type] = $bean_types[$type]->getLabel();
        }
      }
    }

    asort($tiles_options['bean types']);
    asort($tiles_options['blocks']);
  }

  return $tiles_options;
}

/**
 * Whether a block is a tile.
 *
 * @param string $module
 *   The module the block belongs to.
 * @param string $delta
 *   The delta of the block
 *
 * @return bool
 *   True if block is defined as a tile, either as a static block, or if the
 *   block is a bean, then if the bean type is availble to tiles.
 */
function tiles_is_tile($module, $delta) {
  $tiles = &drupal_static(__FUNCTION__, array());

  $slug = $module . '__' . $delta;
  if (!isset($tiles[$slug])) {
    $tiles[$slug] = FALSE;

    $tile_info = tiles_get_tile_types();

    // First check if the block is in the static blocks array.
    if (in_array($module . '__' . $delta, $tile_info['blocks'])) {
      $tiles[$slug] = TRUE;
    }

    // Otherwise, check if block is a bean, and if bean type is available to
    // tiles.
    if ($module == 'bean') {
      $bean = bean_load_delta($delta);
      if (in_array($bean->type, $tile_info['bean types'])) {
        $tiles[$slug] = TRUE;
      }
    }
  }

  return $tiles[$slug];
}

/**
 * Returns a block's width.
 *
 * The block's width is determined by:
 * - Checking for values from hook_tiles_widths().
 * - Setting to default if none of the above produced a width.
 *
 * @return int $width
 */
function tiles_get_width($module, $delta) {
  // Otherwise see if any hook_tiles_widths defines the width for this block.
  $tiles_widths = module_invoke_all('tiles_widths');
  if (isset($tiles_widths[$module][$delta])) {
    return (int) $tiles_widths[$module][$delta];
  }

  // Default to max width.
  return tiles_get_max_step();
}

/**
 * Gets the step count for the current theme.
 */
function tiles_get_steps($theme = NULL) {
  // Default to default frontend theme.
  if (!$theme) {
    $theme = variable_get('theme_default', NULL);
  }
  $steps = theme_get_setting('tiles_steps', $theme);

  // If no theme has defined steps, default to bootstrap steps.
  if (!$steps) {
    for ($i = 1; $i <= TILES_WIDTH_STEPS; $i++) {
      $steps[$i] = number_format($i / TILES_WIDTH_STEPS * 100, 0) . '%';
    }
  }

  return $steps;
}

/**
 * Get the last (max) column step.
 */
function tiles_get_max_step() {
  $steps = tiles_get_steps();
  $steps = array_keys($steps);
  return array_pop($steps);
}

/**
 * Gets the breakpoints for the current theme.
 */
function tiles_get_breakpoints($theme = NULL) {
  // Default to default frontend theme.
  if (!$theme) {
    $theme = variable_get('theme_default', NULL);
  }
  $breakpoints = theme_get_setting('tiles_breakpoints', $theme);

  // If no theme has defined steps, default to bootstrap steps.
  if (!$breakpoints) {
    $breakpoints = array('default' => 'default');
  }

  return $breakpoints;
}

/**
 * Gets the default (last) breakpoint.
 */
function tiles_get_default_breakpoint() {
  $breakpoints = tiles_get_breakpoints();
  end($breakpoints);
  return key($breakpoints);
}

/**
 * Returns the appropriate tiles container given a type.
 *
 * @param string $type
 *   The type of container to return. Defaults to the 'region' type that is
 *   implemented by this module.
 *
 * @param TilesContainer $container
 *   The container object.
 */
function tiles_get_container($type = 'region') {
  $containers = &drupal_static(__FUNCTION__, array());

  if (empty($containers)) {
    foreach (module_implements('tiles_container_info') as $module) {
      $containers = array_merge_recursive($containers, module_invoke($module, 'tiles_container_info'));
    }
    drupal_alter('tiles_container_info', $containers);
  }

  if (isset($containers[$type]) && class_exists($containers[$type])) {
    return new $containers[$type];
  }

  return FALSE;
}

/**
 * Theme implementations.
 */

/**
 * Default implementation of theme_tiles_region().
 * @TODO Do we need this?
 */
function theme_tiles_region($variables) {
  return '<div class="tiles-region">' . $variables['element']['#children'] . '</div>';
}

/**
 * Default implementation of theme_tiles_row().
 */
function theme_tiles_row($variables) {
  return '<div class="tiles-row">' . $variables['element']['#children'] . '</div>';
}

/**
 * Default implementation of theme_tiles_tile().
 */
function theme_tiles_tile($variables) {
  return '<div class="tiles-tile span' . $variables['width'] . '">' . $variables['element']['#children'] . '</div>';
}

/**
 * Preprocess function for theme_tiles_tile().
 */
function template_preprocess_tiles_tile(&$variables) {
  // Expose block width as an available variable to themers.
  $variables['width'] = $variables['element']['#block']->width;
}

/**
 * Private functions
 */

/**
 * Stub function, handled in js.
 */
function _tiles_move($block) {
}

/**
 * Stub function, handled in js.
 */
function _tiles_width($block) {
}

/**
 * Stub function, handled in js.
 */
function _tiles_visibility($block) {
}

/**
 * Check to see if the current user has access to edit the blocks on the current
 * page by checking to see if the user access to edit the current page.
 */
function _tiles_has_block_access() {
  // First check if user has tiles access.
  if (!user_access('arrange tiles')) {
    return FALSE;
  }

  // Node access.
  if ($node = menu_get_object()) {
    return node_access('update', $node);
  }

  // Taxonomy access.
  if ($term = menu_get_object('taxonomy_term', 2)) {
    return user_access('administer taxonomy') || user_access('edit terms in ' . $term->vid);
  }

  return TRUE;
}

/**
 * AJAX Callback: Save the weights and widths of blocks to the current page's context.
 */
function _tiles_save_tiles() {
  // @todo: this should use the save method of the appropriate container object.
  $result = tiles_get_container($_SERVER['HTTP_X_TILES'])->save();
  drupal_json_output(array('result' => $result));
  drupal_exit();
}

/**
 * Get the available regions for adding new blocks to.
 *
 * @param string $type
 *   The TilesContainer type from which to get regions.
 * @param string $context_name
 *   The context name to which tiles are being added.
 */
function _tiles_get_regions($type = 'region', $context_name = '') {
  return tiles_get_container($type)->getRegions($context_name);
}

/**
 * Initialize the javascript for the current page, if there are active
 * tiles.
 */
function _tiles_js_init() {
  static $initialized;

  if (!$initialized) {
    drupal_add_css(drupal_get_path('module', 'tiles') . '/css/tiles.css');
    drupal_add_js(drupal_get_path('module', 'tiles') . '/js/tiles.js');

    $settings = array(
      'tiles' => array(
        'breakpoints' => tiles_get_breakpoints(),
        'steps' => tiles_get_steps(),
        'stepsKeys' => array_keys(tiles_get_steps()),
      ),
    );
    $settings['tiles']['selector'] = current_path();

    drupal_add_js($settings, 'setting');

    $initialized = TRUE;
  }
}

/**
 * Routes page callback request with X-TILES header to appropriate container
 * object.
 */
function tiles_handle_callback_request($page_callback_result) {
  return tiles_get_container($_SERVER['HTTP_X_TILES'])->handleDelivery($page_callback_result);
}
